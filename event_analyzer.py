#!/usr/bin/env python3
"""
Event Analyzer para Upgraded-Happiness
Integra el motor de reglas con el sistema ZeroMQ existente.
Analiza eventos y genera comandos de firewall autom√°ticamente.
"""

import zmq
import json
import time
import uuid
import logging
import threading
from typing import Dict, List, Optional
from dataclasses import asdict
from rule_engine import RuleEngine, FirewallRecommendation
from simple_system_detection import SimpleSystemDetector

logger = logging.getLogger(__name__)


class EventAnalyzer:
    """Analizador de eventos que conecta ML detector con firewall agent"""

    def __init__(self,
                 input_port=5560,  # Recibe del ML detector
                 output_port=5561,  # Env√≠a al firewall agent
                 dashboard_port=5563):  # Env√≠a notificaciones al dashboard

        self.input_port = input_port
        self.output_port = output_port
        self.dashboard_port = dashboard_port
        self.running = False

        # Componentes principales
        self.rule_engine = RuleEngine()
        self.detector = SimpleSystemDetector()
        self.node_id = self.detector.node_id

        # ZeroMQ setup
        self.context = zmq.Context()
        self.input_socket = None
        self.output_socket = None
        self.dashboard_socket = None

        # Modo autom√°tico o manual
        self.auto_send_commands = False  # Por defecto manual

        # Cache de nodos conocidos
        self.known_nodes = {}\n        \n  # Estad√≠sticas\n        self.stats = {\n            'events_analyzed': 0,\n            'recommendations_generated': 0,\n            'commands_sent': 0,\n            'handshakes_processed': 0,\n            'start_time': time.time()\n        }\n        \n        # Queue de recomendaciones pendientes (para aprobaci√≥n manual)\n        self.pending_recommendations = {}\n        \n        logger.info(f"EventAnalyzer initialized on node {self.node_id}")\n    \n    def start(self):\n        \"\"\"Inicia el analizador de eventos\"\"\"\n        try:\n            # Configurar sockets\n            self.input_socket = self.context.socket(zmq.PULL)\n            self.input_socket.bind(f"tcp://*:{self.input_port}")\n            \n            self.output_socket = self.context.socket(zmq.PUSH)\n            self.output_socket.connect(f"tcp://localhost:{self.output_port}")\n            \n            self.dashboard_socket = self.context.socket(zmq.PUSH)\n            self.dashboard_socket.connect(f"tcp://localhost:{self.dashboard_port}")\n            \n            self.running = True\n            \n            print(f\"\\nüß† Event Analyzer Started\")\n            print(f\"üì° Listening on port {self.input_port}\")\n            print(f\"üî• Firewall commands ‚Üí port {self.output_port}\")\n            print(f\"üìä Dashboard notifications ‚Üí port {self.dashboard_port}\")\n            print(f\"ü§ñ Auto-send commands: {'ON' if self.auto_send_commands else 'OFF (Manual approval required)'}\")\n            print(f\"üÜî Analyzer Node ID: {self.node_id}\")\n            print(\"=\" * 70)\n            \n            # Iniciar hilos\n            self.start_threads()\n            \n        except Exception as e:\n            logger.error(f\"Error starting event analyzer: {e}\")\n            raise\n    \n    def start_threads(self):\n        \"\"\"Inicia hilos de procesamiento\"\"\"\n        # Hilo principal de an√°lisis\n        analysis_thread = threading.Thread(target=self.analysis_loop, daemon=True)\n        analysis_thread.start()\n        \n        # Hilo de interfaz interactiva (solo si modo manual)\n        if not self.auto_send_commands:\n            ui_thread = threading.Thread(target=self.interactive_ui, daemon=True)\n            ui_thread.start()\n        \n        # Hilo de estad√≠sticas\n        stats_thread = threading.Thread(target=self.stats_loop, daemon=True)\n        stats_thread.start()\n        \n        # Wait for keyboard interrupt\n        try:\n            while self.running:\n                time.sleep(1)\n        except KeyboardInterrupt:\n            print(\"\\n\\nüõë Stopping Event Analyzer...\")\n            self.running = False\n        finally:\n            self.cleanup()\n    \n    def analysis_loop(self):\n        \"\"\"Loop principal de an√°lisis de eventos\"\"\"\n        logger.info(\"Starting analysis loop...\")\n        \n        while self.running:\n            try:\n                # Recibir evento (con timeout)\n                if self.input_socket.poll(1000):  # 1 segundo timeout\n                    message = self.input_socket.recv_string()\n                    self.process_event_message(message)\n                \n            except zmq.Again:\n                continue\n            except Exception as e:\n                logger.error(f\"Error in analysis loop: {e}\")\n                time.sleep(1)\n    \n    def process_event_message(self, message: str):\n        \"\"\"Procesa un mensaje de evento recibido\"\"\"\n        try:\n            event_data = json.loads(message)\n            self.stats['events_analyzed'] += 1\n            \n            # Manejar handshake de nodo\n            if event_data.get('is_handshake', False):\n                self.process_node_handshake(event_data)\n                return\n            \n            # An√°lisis con motor de reglas\n            recommendations = self.rule_engine.analyze_event(event_data)\n            \n            if recommendations:\n                self.stats['recommendations_generated'] += len(recommendations)\n                self.handle_recommendations(event_data, recommendations)\n            \n        except json.JSONDecodeError as e:\n            logger.error(f\"Invalid JSON in event: {e}\")\n        except Exception as e:\n            logger.error(f\"Error processing event: {e}\")\n    \n    def process_node_handshake(self, event_data: Dict):\n        \"\"\"Procesa handshake de un nodo\"\"\"\n        try:\n            node_id = event_data.get('node_id')\n            if not node_id:\n                return\n            \n            # Extraer informaci√≥n del sistema\n            system_info = event_data.get('system_info', {})\n            \n            self.known_nodes[node_id] = {\n                'hostname': system_info.get('hostname', 'unknown'),\n                'os_name': system_info.get('os_name', 'unknown'),\n                'os_version': system_info.get('os_version', 'unknown'),\n                'firewall_type': system_info.get('firewall_type', 'unknown'),\n                'firewall_status': system_info.get('firewall_status', 'unknown'),\n                'first_seen': time.time(),\n                'last_seen': time.time()\n            }\n            \n            self.stats['handshakes_processed'] += 1\n            \n            print(f\"\\nü§ù New Node Discovered:\")\n            print(f\"   üÜî ID: {node_id}\")\n            print(f\"   üñ•Ô∏è  Host: {self.known_nodes[node_id]['hostname']}\")\n            print(f\"   üíø OS: {self.known_nodes[node_id]['os_name']} {self.known_nodes[node_id]['os_version']}\")\n            print(f\"   üî• Firewall: {self.known_nodes[node_id]['firewall_type']} ({self.known_nodes[node_id]['firewall_status']})\")\n            print(\"‚îÄ\" * 60)\n            \n        except Exception as e:\n            logger.error(f\"Error processing node handshake: {e}\")\n    \n    def handle_recommendations(self, event_data: Dict, recommendations: List[FirewallRecommendation]):\n        \"\"\"Maneja las recomendaciones generadas\"\"\"\n        \n        for rec in recommendations:\n            # Mostrar recomendaci√≥n\n            self.display_recommendation(event_data, rec)\n            \n            if self.auto_send_commands:\n                # Enviar autom√°ticamente\n                self.send_firewall_command(rec)\n            else:\n                # Guardar para aprobaci√≥n manual\n                rec_id = str(uuid.uuid4())[:8]\n                self.pending_recommendations[rec_id] = {\n                    'recommendation': rec,\n                    'event': event_data,\n                    'timestamp': time.time()\n                }\n                \n                print(f\"   üí° Use 'approve {rec_id}' to apply this recommendation\")\n    \n    def display_recommendation(self, event_data: Dict, rec: FirewallRecommendation):\n        \"\"\"Muestra una recomendaci√≥n en pantalla\"\"\"\n        timestamp = time.strftime(\"%H:%M:%S\", time.localtime())\n        \n        # Color seg√∫n prioridad\n        if rec.priority == 'CRITICAL':\n            color = \"\\033[91m\"  # Red\n            icon = \"üö®\"\n        elif rec.priority == 'HIGH':\n            color = \"\\033[93m\"  # Yellow\n            icon = \"‚ö†Ô∏è\"\n        elif rec.priority == 'MEDIUM':\n            color = \"\\033[96m\"  # Cyan\n            icon = \"üí°\"\n        else:\n            color = \"\\033[92m\"  # Green\n            icon = \"‚ÑπÔ∏è\"\n        \n        reset_color = \"\\033[0m\"\n        \n        print(f\"\\n{color}[{timestamp}] {icon} RECOMMENDATION ({rec.priority}){reset_color}\")\n        print(f\"üéØ Action: {rec.action}\")\n        print(f\"üîó Target: {rec.target_ip}\" + (f\":{rec.target_port}\" if rec.target_port else \"\"))\n        print(f\"üìù Reason: {rec.reason}\")\n        print(f\"‚è±Ô∏è  Duration: {rec.duration_seconds}s\")\n        print(f\"üé≤ Confidence: {rec.confidence:.2f}\")\n        print(f\"üìè Rule: {rec.rule_triggered}\")\n        print(f\"üìä Event: {event_data.get('source_ip', 'unknown')} ‚Üí {event_data.get('target_ip', 'unknown')}\")\n        \n        if rec.additional_context:\n            print(f\"üîç Context: {rec.additional_context}\")\n    \n    def send_firewall_command(self, rec: FirewallRecommendation):\n        \"\"\"Env√≠a comando al firewall agent\"\"\"\n        try:\n            command = {\n                'command_id': str(uuid.uuid4()),\n                'action': rec.action,\n                'target_ip': rec.target_ip,\n                'target_port': rec.target_port,\n                'duration_seconds': rec.duration_seconds,\n                'reason': rec.reason,\n                'priority': rec.priority,\n                'dry_run': True,  # Siempre dry-run por seguridad\n                'timestamp': time.time(),\n                'generated_by': 'rule_engine'\n            }\n            \n            command_json = json.dumps(command)\n            self.output_socket.send_string(command_json)\n            \n            self.stats['commands_sent'] += 1\n            \n            print(f\"   ‚úÖ Command sent to firewall agent\")\n            \n        except Exception as e:\n            logger.error(f\"Error sending firewall command: {e}\")\n    \n    def interactive_ui(self):\n        \"\"\"Interfaz interactiva para aprobar recomendaciones manualmente\"\"\"\n        print(f\"\\nüí¨ Interactive Mode Active\")\n        print(f\"   Commands: 'approve <id>', 'list', 'stats', 'help', 'quit'\\n\")\n        \n        while self.running:\n            try:\n                command = input(\"analyzer> \").strip().lower()\n                \n                if command == 'quit' or command == 'exit':\n                    self.running = False\n                    break\n                elif command == 'help':\n                    self.show_help()\n                elif command == 'list':\n                    self.list_pending_recommendations()\n                elif command == 'stats':\n                    self.print_statistics()\n                elif command.startswith('approve '):\n                    rec_id = command.split(' ', 1)[1]\n                    self.approve_recommendation(rec_id)\n                elif command == 'auto on':\n                    self.auto_send_commands = True\n                    print(\"ü§ñ Auto-send enabled\")\n                elif command == 'auto off':\n                    self.auto_send_commands = False\n                    print(\"üë§ Manual approval required\")\n                elif command == 'clear':\n                    self.pending_recommendations.clear()\n                    print(\"üóëÔ∏è  Pending recommendations cleared\")\n                elif command:\n                    print(f\"‚ùì Unknown command: {command}. Type 'help' for options.\")\n                    \n            except EOFError:\n                break\n            except KeyboardInterrupt:\n                break\n            except Exception as e:\n                logger.error(f\"Error in interactive UI: {e}\")\n    \n    def show_help(self):\n        \"\"\"Muestra ayuda de comandos\"\"\"\n        print(\"\\nüìñ Available Commands:\")\n        print(\"   approve <id>  - Approve pending recommendation\")\n        print(\"   list          - Show pending recommendations\")\n        print(\"   stats         - Show analyzer statistics\")\n        print(\"   auto on/off   - Toggle automatic command sending\")\n        print(\"   clear         - Clear pending recommendations\")\n        print(\"   help          - Show this help\")\n        print(\"   quit          - Exit analyzer\")\n    \n    def list_pending_recommendations(self):\n        \"\"\"Lista recomendaciones pendientes\"\"\"\n        if not self.pending_recommendations:\n            print(\"üì≠ No pending recommendations\")\n            return\n        \n        print(f\"\\nüìã Pending Recommendations ({len(self.pending_recommendations)}):\")\n        print(\"‚ïê\" * 60)\n        \n        for rec_id, data in self.pending_recommendations.items():\n            rec = data['recommendation']\n            age = time.time() - data['timestamp']\n            \n            print(f\"üÜî {rec_id}: {rec.action} {rec.target_ip} ({rec.priority})\")\n            print(f\"   üìù {rec.reason}\")\n            print(f\"   ‚è∞ {age:.0f}s ago\")\n            print(\"‚îÄ\" * 40)\n    \n    def approve_recommendation(self, rec_id: str):\n        \"\"\"Aprueba una recomendaci√≥n pendiente\"\"\"\n        if rec_id not in self.pending_recommendations:\n            print(f\"‚ùå Recommendation {rec_id} not found\")\n            return\n        \n        data = self.pending_recommendations[rec_id]\n        rec = data['recommendation']\n        \n        print(f\"‚úÖ Approving recommendation {rec_id}\")\n        self.send_firewall_command(rec)\n        \n        # Remover de pendientes\n        del self.pending_recommendations[rec_id]\n    \n    def stats_loop(self):\n        \"\"\"Loop de estad√≠sticas peri√≥dicas\"\"\"\n        while self.running:\n            time.sleep(60)  # Cada minuto\n            if self.stats['events_analyzed'] > 0:\n                logger.info(f\"Stats: {self.stats['events_analyzed']} events, {self.stats['recommendations_generated']} recommendations\")\n    \n    def print_statistics(self):\n        \"\"\"Imprime estad√≠sticas detalladas\"\"\"\n        uptime = time.time() - self.stats['start_time']\n        \n        print(f\"\\nüìä Event Analyzer Statistics\")\n        print(\"‚ïê\" * 40)\n        print(f\"‚è±Ô∏è  Uptime: {uptime:.0f}s\")\n        print(f\"üì® Events Analyzed: {self.stats['events_analyzed']}\")\n        print(f\"üí° Recommendations Generated: {self.stats['recommendations_generated']}\")\n        print(f\"üî• Commands Sent: {self.stats['commands_sent']}\")\n        print(f\"ü§ù Handshakes Processed: {self.stats['handshakes_processed']}\")\n        print(f\"üñ•Ô∏è  Known Nodes: {len(self.known_nodes)}\")\n        print(f\"‚è≥ Pending Recommendations: {len(self.pending_recommendations)}\")\n        print(f\"ü§ñ Auto-send Mode: {'ON' if self.auto_send_commands else 'OFF'}\")\n        \n        # Estad√≠sticas del motor de reglas\n        rule_stats = self.rule_engine.get_statistics()\n        print(f\"\\nüß† Rule Engine Stats:\")\n        for rule, count in rule_stats['rules_triggered'].items():\n            print(f\"   üìè {rule}: {count}\")\n        \n        # Nodos conocidos\n        if self.known_nodes:\n            print(f\"\\nüñ•Ô∏è  Known Nodes:\")\n            for node_id, info in self.known_nodes.items():\n                age = time.time() - info['last_seen']\n                status = \"üü¢\" if age < 300 else \"üî¥\"  # 5 min threshold\n                print(f\"   {status} {info['hostname']} ({info['os_name']}, {info['firewall_type']})\")\n    \n    def cleanup(self):\n        \"\"\"Limpia recursos\"\"\"\n        if self.input_socket:\n            self.input_socket.close()\n        if self.output_socket:\n            self.output_socket.close()\n        if self.dashboard_socket:\n            self.dashboard_socket.close()\n        if self.context:\n            self.context.term()\n\n\ndef main():\n    \"\"\"Funci√≥n principal\"\"\"\n    import argparse\n    \n    # Configurar logging\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    )\n    \n    # Argumentos\n    parser = argparse.ArgumentParser(description='Event Analyzer for Upgraded-Happiness')\n    parser.add_argument('--input-port', type=int, default=5560, help='Input port for events')\n    parser.add_argument('--output-port', type=int, default=5561, help='Output port for firewall commands')\n    parser.add_argument('--auto-send', action='store_true', help='Automatically send firewall commands')\n    \n    args = parser.parse_args()\n    \n    # Crear y ejecutar analizador\n    analyzer = EventAnalyzer(\n        input_port=args.input_port,\n        output_port=args.output_port\n    )\n    \n    if args.auto_send:\n        analyzer.auto_send_commands = True\n        print(\"ü§ñ Auto-send mode enabled\")\n    \n    try:\n        analyzer.start()\n    except KeyboardInterrupt:\n        print(\"\\nüëã Goodbye!\")\n    finally:\n        analyzer.print_statistics()\n\n\nif __name__ == \"__main__\":\n    main()