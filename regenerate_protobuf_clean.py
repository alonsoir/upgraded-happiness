#!/usr/bin/env python3
"""
Regenerar protobuf de manera limpia
"""

import os
import subprocess
import shutil


def backup_and_clean():
    """Hacer backup y limpiar archivos corrompidos"""

    pb2_file = "src/protocols/protobuf/network_event_pb2.py"

    if os.path.exists(pb2_file):
        backup_file = f"{pb2_file}.corrupted"
        shutil.copy2(pb2_file, backup_file)
        print(f"‚úÖ Backup del archivo corrompido: {backup_file}")

        # Eliminar archivo corrompido
        os.remove(pb2_file)
        print(f"‚úÖ Eliminado archivo corrompido: {pb2_file}")


def regenerate_protobuf():
    """Regenerar protobuf usando protoc"""

    print("üîÑ Regenerando protobuf...")

    # Comando para regenerar
    cmd = "protoc --python_out=. src/protocols/protobuf/network_event.proto"

    try:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)
        print("‚úÖ Protobuf regenerado exitosamente")

        # Verificar que el archivo se cre√≥
        pb2_file = "src/protocols/protobuf/network_event_pb2.py"
        if os.path.exists(pb2_file):
            print(f"‚úÖ Archivo creado: {pb2_file}")

            # Mostrar las primeras l√≠neas para verificar
            with open(pb2_file, 'r') as f:
                lines = f.readlines()

            print("üìù Primeras l√≠neas del archivo regenerado:")
            print("=" * 50)
            for i, line in enumerate(lines[:15]):
                print(f"{i + 1:2d}: {line.rstrip()}")
            print("=" * 50)

            return True
        else:
            print(f"‚ùå No se cre√≥ el archivo: {pb2_file}")
            return False

    except subprocess.CalledProcessError as e:
        print(f"‚ùå Error ejecutando protoc: {e}")
        print(f"stdout: {e.stdout}")
        print(f"stderr: {e.stderr}")
        return False


def create_compatible_version():
    """Crear una versi√≥n compatible manualmente si protoc falla"""

    pb2_file = "src/protocols/protobuf/network_event_pb2.py"

    compatible_content = '''# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: src/protocols/protobuf/network_event.proto
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder

_sym_db = _symbol_database.Default()

DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\\n+src/protocols/protobuf/network_event.proto\\x12\\x0enetwork.events"\\xe1\\x01\\n\\x0cNetworkEvent\\x12\\x10\\n\\x08event_id\\x18\\x01 \\x01(\\t\\x12\\x11\\n\\ttimestamp\\x18\\x02 \\x01(\\x03\\x12\\x11\\n\\tsource_ip\\x18\\x03 \\x01(\\t\\x12\\x11\\n\\ttarget_ip\\x18\\x04 \\x01(\\t\\x12\\x13\\n\\x0bpacket_size\\x18\\x05 \\x01(\\x05\\x12\\x11\\n\\tdest_port\\x18\\x06 \\x01(\\x05\\x12\\x10\\n\\x08src_port\\x18\\x07 \\x01(\\x05\\x12\\x10\\n\\x08agent_id\\x18\\x08 \\x01(\\t\\x12\\x15\\n\\ranomaly_score\\x18\\t \\x01(\\x02\\x12\\x10\\n\\x08latitude\\x18\\n \\x01(\\x01\\x12\\x11\\n\\tlongitude\\x18\\x0b \\x01(\\x01b\\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'src.protocols.protobuf.network_event_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
    DESCRIPTOR._loaded_options = None
    _globals['_NETWORKEVENT']._serialized_start=64
    _globals['_NETWORKEVENT']._serialized_end=289
'''

    with open(pb2_file, 'w') as f:
        f.write(compatible_content)

    print(f"‚úÖ Versi√≥n compatible creada: {pb2_file}")


def test_import():
    """Probar que la importaci√≥n funcione"""

    print("üß™ Probando importaci√≥n...")

    test_code = '''
import sys
import os
sys.path.insert(0, os.getcwd())

try:
    from src.protocols.protobuf import network_event_pb2
    print("‚úÖ Importaci√≥n exitosa")

    # Probar crear instancia
    event = network_event_pb2.NetworkEvent()
    event.event_id = "test_123"
    print("‚úÖ Instancia creada")

    # Probar serializaci√≥n
    data = event.SerializeToString()
    print(f"‚úÖ Serializaci√≥n OK: {len(data)} bytes")

except Exception as e:
    print(f"‚ùå Error: {e}")
    import traceback
    traceback.print_exc()
'''

    # Escribir y ejecutar test
    with open('temp_test.py', 'w') as f:
        f.write(test_code)

    try:
        result = subprocess.run("python temp_test.py", shell=True, capture_output=True, text=True)
        print(result.stdout)
        if result.stderr:
            print("Errores:", result.stderr)

        success = "‚úÖ Serializaci√≥n OK" in result.stdout
        return success
    finally:
        # Limpiar archivo temporal
        if os.path.exists('temp_test.py'):
            os.remove('temp_test.py')


if __name__ == "__main__":
    print("üöÄ REGENERACI√ìN LIMPIA DE PROTOBUF")
    print("=" * 50)

    # Paso 1: Backup y limpiar
    backup_and_clean()

    # Paso 2: Intentar regenerar con protoc
    if regenerate_protobuf():
        # Paso 3: Probar que funcione
        if test_import():
            print("\\nüéâ ¬°PROTOBUF REGENERADO EXITOSAMENTE!")
            print("\\nüß™ Ahora ejecuta:")
            print("   python test_protobuf_simple.py")
            print("   python agent_scapy_fixed.py")
        else:
            print("\\n‚ö†Ô∏è  Protobuf regenerado pero hay problemas de importaci√≥n")
            print("Creando versi√≥n compatible...")
            create_compatible_version()
            if test_import():
                print("‚úÖ Versi√≥n compatible funciona")
    else:
        print("\\n‚ö†Ô∏è  Error con protoc, creando versi√≥n compatible...")
        create_compatible_version()
        if test_import():
            print("‚úÖ Versi√≥n compatible funciona")